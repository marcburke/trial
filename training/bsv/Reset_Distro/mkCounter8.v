//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Dec 31 15:20:56 EST 2015
//
//
// Ports:
// Name                         I/O  size props
// read                           O     8 reg
// RDY_read                       O     1 const
// RDY_load                       O     1 const
// RDY_increment                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// load_newval                    I     8
// EN_load                        I     1
// EN_increment                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCounter8(CLK,
		  RST_N,

		  read,
		  RDY_read,

		  load_newval,
		  EN_load,
		  RDY_load,

		  EN_increment,
		  RDY_increment);
  input  CLK;
  input  RST_N;

  // value method read
  output [7 : 0] read;
  output RDY_read;

  // action method load
  input  [7 : 0] load_newval;
  input  EN_load;
  output RDY_load;

  // action method increment
  input  EN_increment;
  output RDY_increment;

  // signals for module outputs
  wire [7 : 0] read;
  wire RDY_increment, RDY_load, RDY_read;

  // register value
  reg [7 : 0] value;
  wire [7 : 0] value$D_IN;
  wire value$EN;

  // rule scheduling signals
  wire CAN_FIRE_increment, CAN_FIRE_load, WILL_FIRE_increment, WILL_FIRE_load;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_value$write_1__VAL_2;

  // value method read
  assign read = value ;
  assign RDY_read = 1'd1 ;

  // action method load
  assign RDY_load = 1'd1 ;
  assign CAN_FIRE_load = 1'd1 ;
  assign WILL_FIRE_load = EN_load ;

  // action method increment
  assign RDY_increment = 1'd1 ;
  assign CAN_FIRE_increment = 1'd1 ;
  assign WILL_FIRE_increment = EN_increment ;

  // inputs to muxes for submodule ports
  assign MUX_value$write_1__VAL_2 = value + 8'd1 ;

  // register value
  assign value$D_IN = EN_load ? load_newval : MUX_value$write_1__VAL_2 ;
  assign value$EN = EN_load || EN_increment ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        value <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (value$EN) value <= `BSV_ASSIGNMENT_DELAY value$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    value = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCounter8

