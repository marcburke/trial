//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Dec 31 15:31:39 EST 2015
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTbResetDistro(CLK,
		       RST_N);
  input  CLK;
  input  RST_N;

  // register reset_d1
  reg reset_d1;
  wire reset_d1$D_IN, reset_d1$EN;

  // register reset_pk
  reg reset_pk;
  wire reset_pk$D_IN, reset_pk$EN;

  // register state
  reg [15 : 0] state;
  reg [15 : 0] state$D_IN;
  wire state$EN;

  // ports of submodule counter1
  wire [7 : 0] counter1$load_newval, counter1$read;
  wire counter1$EN_increment, counter1$EN_load;

  // ports of submodule counter2
  wire [7 : 0] counter2$load_newval;
  wire counter2$EN_increment, counter2$EN_load;

  // ports of submodule rst1
  wire rst1$OUT_RST;

  // ports of submodule rst2
  wire rst2$OUT_RST;

  // rule scheduling signals
  wire CAN_FIRE_RL_done,
       CAN_FIRE_RL_step0,
       CAN_FIRE_RL_step1,
       CAN_FIRE_RL_step2,
       CAN_FIRE_RL_step3,
       WILL_FIRE_RL_done,
       WILL_FIRE_RL_step0,
       WILL_FIRE_RL_step1,
       WILL_FIRE_RL_step2,
       WILL_FIRE_RL_step3;

  // inputs to muxes for submodule ports
  wire MUX_state$write_1__SEL_1;

  // submodule counter1
  mkCounter8 counter1(.CLK(CLK),
		      .RST_N(rst1$OUT_RST),
		      .load_newval(counter1$load_newval),
		      .EN_load(counter1$EN_load),
		      .EN_increment(counter1$EN_increment),
		      .read(counter1$read),
		      .RDY_read(),
		      .RDY_load(),
		      .RDY_increment());

  // submodule counter2
  mkCounter8 counter2(.CLK(CLK),
		      .RST_N(rst2$OUT_RST),
		      .load_newval(counter2$load_newval),
		      .EN_load(counter2$EN_load),
		      .EN_increment(counter2$EN_increment),
		      .read(),
		      .RDY_read(),
		      .RDY_load(),
		      .RDY_increment());

  // submodule rst1
  SyncReset #(.RSTDELAY(32'd0)) rst1(.CLK(CLK),
				     .IN_RST(RST_N),
				     .OUT_RST(rst1$OUT_RST));

  // submodule rst2
  SyncReset #(.RSTDELAY(32'd1)) rst2(.CLK(CLK),
				     .IN_RST(RST_N),
				     .OUT_RST(rst2$OUT_RST));

  // rule RL_step0
  assign CAN_FIRE_RL_step0 = state == 16'd0 ;
  assign WILL_FIRE_RL_step0 = CAN_FIRE_RL_step0 ;

  // rule RL_step1
  assign CAN_FIRE_RL_step1 = state == 16'd1 ;
  assign WILL_FIRE_RL_step1 = CAN_FIRE_RL_step1 ;

  // rule RL_step2
  assign CAN_FIRE_RL_step2 = state == 16'd2 ;
  assign WILL_FIRE_RL_step2 = CAN_FIRE_RL_step2 ;

  // rule RL_step3
  assign CAN_FIRE_RL_step3 = state == 16'd3 ;
  assign WILL_FIRE_RL_step3 = CAN_FIRE_RL_step3 ;

  // rule RL_done
  assign CAN_FIRE_RL_done = state == 16'd4 ;
  assign WILL_FIRE_RL_done = CAN_FIRE_RL_done ;

  // inputs to muxes for submodule ports
  assign MUX_state$write_1__SEL_1 =
	     WILL_FIRE_RL_step1 && counter1$read == 8'h04 ;

  // register reset_d1
  assign reset_d1$D_IN = 1'b0 ;
  assign reset_d1$EN = CAN_FIRE_RL_step1 ;

  // register reset_pk
  assign reset_pk$D_IN = 1'b0 ;
  assign reset_pk$EN = 1'b0 ;

  // register state
  always@(MUX_state$write_1__SEL_1 or
	  WILL_FIRE_RL_step0 or WILL_FIRE_RL_step2 or WILL_FIRE_RL_step3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state$write_1__SEL_1: state$D_IN = 16'd2;
      WILL_FIRE_RL_step0: state$D_IN = 16'd1;
      WILL_FIRE_RL_step2: state$D_IN = 16'd3;
      WILL_FIRE_RL_step3: state$D_IN = 16'd4;
      default: state$D_IN = 16'b1010101010101010 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     WILL_FIRE_RL_step1 && counter1$read == 8'h04 ||
	     WILL_FIRE_RL_step0 ||
	     WILL_FIRE_RL_step2 ||
	     WILL_FIRE_RL_step3 ;

  // submodule counter1
  assign counter1$load_newval = 8'h0 ;
  assign counter1$EN_load = 1'b0 ;
  assign counter1$EN_increment = CAN_FIRE_RL_step1 ;

  // submodule counter2
  assign counter2$load_newval = 8'h0 ;
  assign counter2$EN_load = 1'b0 ;
  assign counter2$EN_increment = CAN_FIRE_RL_step1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        reset_d1 <= `BSV_ASSIGNMENT_DELAY 1'd1;
	reset_pk <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (reset_d1$EN) reset_d1 <= `BSV_ASSIGNMENT_DELAY reset_d1$D_IN;
	if (reset_pk$EN) reset_pk <= `BSV_ASSIGNMENT_DELAY reset_pk$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    reset_d1 = 1'h0;
    reset_pk = 1'h0;
    state = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_done) $display("TESTS FINISHED");
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_done) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkTbResetDistro

